const TelegramBot = require('node-telegram-bot-api');
const { TelegramClient, Api } = require('telegram');
const { StringSession } = require('telegram/sessions');
const input = require('input');
const chalk = require('chalk');
const fs = require('fs-extra');
const path = require('path');
require('dotenv').config({ path: './config.env' });

const TechnicalAnalyzer = require('./src/TechnicalAnalyzer');
const ImageProcessor = require('./src/ImageProcessor');
const BinanceAPI = require('./src/BinanceAPI');
const SignalGenerator = require('./src/SignalGenerator');
const SmartMoneyAnalyzer = require('./src/SmartMoneyAnalyzer');
const Logger = require('./src/Logger');
const AutoTrader = require('./src/AutoTrader');

class DefBinanceProfessionalBot {
    constructor() {
        // Bot API para comandos con mejor manejo de errores
        this.bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { 
            polling: {
                interval: 2000,
                autoStart: true,
                params: {
                    timeout: 10
                }
            }
        });
        
        // Tu Telegram API para leer mensajes completos
        this.apiId = parseInt(process.env.TELEGRAM_API_ID);
        this.apiHash = process.env.TELEGRAM_API_HASH;
        this.sessionString = process.env.TELEGRAM_SESSION_STRING;
        this.telegramClient = null;
        
        this.technicalAnalyzer = new TechnicalAnalyzer();
        this.imageProcessor = new ImageProcessor();
        this.binanceAPI = new BinanceAPI();
        this.signalGenerator = new SignalGenerator();
        this.smartMoneyAnalyzer = new SmartMoneyAnalyzer();
        this.logger = new Logger();
        
        // AutoTrader para operaciones autom√°ticas (DESHABILITADO por defecto)
        this.autoTrader = new AutoTrader(
            process.env.BINANCE_API_KEY,
            process.env.BINANCE_SECRET_KEY,
            this.logger
        );
        
        this.isRunning = false;
        this.processedSignals = new Set();
        this.signalCount = { hourly: 0, lastHour: new Date().getHours() };
        this.lastAnalysisTime = 0;
        
        this.setupDirectories();
        this.setupEventHandlers();
        this.initializeTelegramAPI();
        
        console.log(chalk.bold.green('ü§ñ DEF BINANCE PROFESSIONAL BOT INICIADO'));
        console.log(chalk.cyan('üìä An√°lisis T√©cnico Profesional Activado'));
        console.log(chalk.yellow('üéØ Monitoreando: Grupo de Se√±ales (-1001959577386)'));
        console.log(chalk.white('üí¨ Enviando se√±ales al mismo grupo'));
        console.log('');
    }

    setupDirectories() {
        const dirs = [
            './data',
            './data/images',
            './data/analysis',
            './data/signals',
            './logs'
        ];
        
        dirs.forEach(dir => {
            fs.ensureDirSync(dir);
        });
    }

    async initializeTelegramAPI() {
        try {
            console.log(chalk.blue('üîó Inicializando tu Telegram API...'));
            
            const session = new StringSession(this.sessionString);
            this.telegramClient = new TelegramClient(session, this.apiId, this.apiHash, {
                connectionRetries: 5,
            });

            await this.telegramClient.start({
                phoneNumber: async () => '',
                password: async () => '',
                phoneCode: async () => '',
                onError: (err) => console.log(err),
            });

            console.log(chalk.green('‚úÖ Telegram API conectada - Acceso completo activado'));
            
            // Configurar listener para el grupo de se√±ales
            await this.setupMessageListener();
            
        } catch (error) {
            console.error(chalk.red('‚ùå Error inicializando Telegram API:'), error);
            console.log(chalk.yellow('‚ö†Ô∏è Continuando solo con Bot API...'));
        }
    }

    async setupMessageListener() {
        try {
            const sourceChannelId = process.env.SOURCE_CHANNEL_ID;
            console.log(chalk.yellow(`üëÇ Configurando listener para ${sourceChannelId}...`));
            
            const { NewMessage } = require('telegram/events');
            
            this.telegramClient.addEventHandler(async (event) => {
                try {
                    if (event.message) {
                        console.log(chalk.green('üì® ¬°Nuevo mensaje detectado!'));
                        console.log(chalk.cyan(`üìù Mensaje: ${event.message.message?.substring(0, 100) || 'Sin texto'}...`));
                        await this.processNewMessage(event.message);
                    }
                } catch (error) {
                    console.error(chalk.red('‚ùå Error procesando evento:'), error);
                }
            }, new NewMessage({}));
            
            console.log(chalk.green('‚úÖ Listener configurado correctamente'));
            
            // Bot listo para funcionar autom√°ticamente
            
        } catch (error) {
            console.error(chalk.red('‚ùå Error configurando listener:'), error);
        }
    }

    async processNewMessage(message) {
        try {
            console.log(chalk.blue('üîç Procesando nuevo mensaje...'));
            
            const text = message.message || '';
            
            // Ignorar mensajes del propio bot para evitar loops
            if (text.includes('BOT F77 - AN√ÅLISIS PROFESIONAL')) {
                console.log(chalk.yellow('‚ö†Ô∏è Ignorando mensaje del propio bot'));
                return;
            }
            console.log(chalk.cyan(`üìù Texto: ${text.substring(0, 100)}...`));
            
            // Extraer s√≠mbolo
            const symbol = this.extractSymbolFromText(text);
            
            if (symbol) {
                console.log(chalk.green(`üéØ Token detectado: ${symbol}`));
                
                // Crear ID √∫nico para la se√±al basado en s√≠mbolo y contenido
                const signalId = `${symbol}_${text.substring(0, 50).replace(/\s+/g, '_')}`;
                
                // Verificar si ya procesamos esta se√±al
                if (this.processedSignals.has(signalId)) {
                    console.log(chalk.yellow(`‚ö†Ô∏è Se√±al ${symbol} ya procesada, ignorando duplicado`));
                    return;
                }
                
                // Control de rate limiting - esperar al menos 10 segundos entre an√°lisis
                const now = Date.now();
                const timeSinceLastAnalysis = now - this.lastAnalysisTime;
                if (timeSinceLastAnalysis < 10000) {
                    console.log(chalk.yellow(`‚è≥ Esperando ${Math.ceil((10000 - timeSinceLastAnalysis) / 1000)}s antes del pr√≥ximo an√°lisis...`));
                    return;
                }
                this.lastAnalysisTime = now;
                
                // Marcar se√±al como procesada
                this.processedSignals.add(signalId);
                
                // Extraer informaci√≥n completa de la se√±al
                const signalInfo = this.extractSignalInfo(text);
                
                await this.performUltraFastAnalysis(symbol, signalInfo, message.id);
            } else {
                console.log(chalk.yellow('‚ö†Ô∏è No se detect√≥ token en el mensaje'));
            }
            
        } catch (error) {
            console.error(chalk.red('‚ùå Error procesando mensaje:'), error);
        }
    }

    setupEventHandlers() {
        // Manejar mensajes del canal fuente
        this.bot.on('channel_post', async (msg) => {
            if (this.isFromSourceChannel(msg)) {
                await this.processChannelMessage(msg);
            }
        });

        // Manejar mensajes de grupos
        this.bot.on('message', async (msg) => {
            if (this.isFromSourceChannel(msg)) {
                await this.processChannelMessage(msg);
            }
        });

        // Manejar comandos directos
        this.bot.onText(/\/start/, (msg) => {
            this.sendWelcomeMessage(msg.chat.id);
        });

        this.bot.onText(/\/status/, (msg) => {
            this.sendStatusMessage(msg.chat.id);
        });

        this.bot.onText(/\/analyze (.+)/, async (msg, match) => {
            const symbol = match[1].toUpperCase();
            await this.manualAnalysis(msg.chat.id, symbol);
        });

        this.bot.onText(/\/listgroups/, async (msg) => {
            await this.listAllGroups(msg.chat.id);
        });

        this.bot.onText(/\/findvolumen/, async (msg) => {
            await this.findVolumenGroup(msg.chat.id);
        });

        this.bot.onText(/\/test/, async (msg) => {
            await this.testSignal(msg.chat.id);
        });


        this.bot.onText(/\/check/, async (msg) => {
            await this.checkGroupAccess(msg.chat.id);
        });

        this.bot.onText(/\/getchatid/, async (msg) => {
            await this.bot.sendMessage(msg.chat.id, `üìã Chat ID: ${msg.chat.id}\nüë• Tipo: ${msg.chat.type}\nüìù T√≠tulo: ${msg.chat.title || 'Sin t√≠tulo'}`);
        });

        // üöÄ COMANDOS DE TRADING AUTOM√ÅTICO
        this.bot.onText(/\/trading_enable/, async (msg) => {
            await this.handleTradingEnable(msg.chat.id);
        });

        this.bot.onText(/\/trading_disable/, async (msg) => {
            await this.handleTradingDisable(msg.chat.id);
        });

        this.bot.onText(/\/trading_stats/, async (msg) => {
            await this.handleTradingStats(msg.chat.id);
        });

        // Manejo de errores
        this.bot.on('error', (error) => {
            this.logger.error('Bot error:', error);
        });

        this.bot.on('polling_error', (error) => {
            // Solo loggear errores cr√≠ticos, ignorar errores temporales de red
            if (!error.message.includes('ENOTFOUND') && !error.message.includes('ECONNRESET')) {
                this.logger.error('Polling error:', error);
            }
            
            // Intentar reconectar despu√©s de errores de red
            if (error.message.includes('ENOTFOUND') || error.message.includes('ECONNRESET')) {
                setTimeout(() => {
                    console.log('üîÑ Intentando reconectar...');
                }, 5000);
            }
        });
    }

    isFromSourceChannel(msg) {
        const sourceChannelId = process.env.SOURCE_CHANNEL_ID;
        const sourceChannelUsername = process.env.SOURCE_CHANNEL_USERNAME;
        
        return msg.chat.id.toString() === sourceChannelId || 
               msg.chat.username === sourceChannelUsername;
    }

    async processChannelMessage(msg) {
        try {
            this.logger.info(`üì® Nuevo mensaje del canal: ${msg.message_id}`);
            
            // Verificar l√≠mite de se√±ales por hora
            if (!this.checkHourlyLimit()) {
                this.logger.warn('‚è∞ L√≠mite de se√±ales por hora alcanzado');
                return;
            }

            let symbol = null;

            // Procesar imagen si existe
            if (msg.photo && msg.photo.length > 0) {
                this.logger.info('üñºÔ∏è Procesando imagen...');
                symbol = await this.processImageMessage(msg);
            }

            // Procesar texto si existe
            if (msg.text || msg.caption) {
                const text = msg.text || msg.caption;
                this.logger.info(`üìù Procesando texto: ${text.substring(0, 100)}...`);
                
                if (!symbol) {
                    symbol = this.extractSymbolFromText(text);
                }
            }

            if (symbol) {
                this.logger.info(`üéØ Token detectado: ${symbol}`);
                
                // Extraer informaci√≥n completa de la se√±al
                const signalInfo = this.extractSignalInfo(text || msg.caption || '');
                
                await this.performUltraFastAnalysis(symbol, signalInfo, msg.message_id);
            } else {
                this.logger.warn('‚ùå No se pudo extraer s√≠mbolo del mensaje');
            }

        } catch (error) {
            this.logger.error('Error procesando mensaje del canal:', error);
        }
    }

    async processImageMessage(msg) {
        try {
            const photo = msg.photo[msg.photo.length - 1]; // Imagen de mayor resoluci√≥n
            const fileId = photo.file_id;
            
            // Descargar imagen
            const fileInfo = await this.bot.getFile(fileId);
            const filePath = `./data/images/${Date.now()}_${fileId}.jpg`;
            
            await this.bot.downloadFile(fileId, './data/images/');
            
            // Extraer texto de la imagen usando OCR
            const extractedText = await this.imageProcessor.extractTextFromImage(filePath);
            this.logger.info(`üìñ Texto extra√≠do: ${extractedText}`);
            
            // Extraer s√≠mbolo del texto
            const symbol = this.extractSymbolFromText(extractedText);
            
            return symbol;
            
        } catch (error) {
            this.logger.error('Error procesando imagen:', error);
            return null;
        }
    }

    extractSymbolFromText(text) {
        try {
            // Patrones para detectar s√≠mbolos de criptomonedas (incluyendo formato #AGTUSDT)
            const patterns = [
                /#([A-Z]{2,10}USDT)/gi,          // #AGTUSDT, #BTCUSDT
                /([A-Z]{2,10})USDT/gi,           // BTCUSDT, ETHUSDT
                /([A-Z]{2,10})\/USDT/gi,         // BTC/USDT
                /([A-Z]{2,10})\s*USDT/gi,        // BTC USDT
                /\$([A-Z]{2,10})/gi,             // $BTC
                /([A-Z]{2,10})\s*PERP/gi,        // BTC PERP
                /([A-Z]{2,10})\s*futures?/gi,    // BTC futures
                /signal[:\s]*([A-Z]{2,10})/gi,   // Signal: BTC
                /([A-Z]{2,10})\s*signal/gi       // BTC signal
            ];

            for (const pattern of patterns) {
                const matches = text.match(pattern);
                if (matches && matches.length > 0) {
                    let symbol = matches[0].replace(/[^A-Z]/g, '');
                    
                    // Si ya termina en USDT, usar tal como est√°
                    if (symbol.endsWith('USDT')) {
                        return symbol;
                    }
                    
                    // Filtrar s√≠mbolos conocidos
                    if (this.isValidCryptoSymbol(symbol)) {
                        return symbol + 'USDT';
                    }
                }
            }

            return null;
        } catch (error) {
            this.logger.error('Error extrayendo s√≠mbolo:', error);
            return null;
        }
    }

    isValidCryptoSymbol(symbol) {
        const validSymbols = [
            'BTC', 'ETH', 'BNB', 'ADA', 'SOL', 'XRP', 'DOGE', 'MATIC', 'DOT', 'AVAX',
            'LINK', 'UNI', 'ATOM', 'XLM', 'ALGO', 'VET', 'FIL', 'AAVE', 'SUSHI', 'COMP',
            'LTC', 'BCH', 'ETC', 'TRX', 'XTZ', 'NEAR', 'LUNA', 'FTT', 'CRO', 'LEO',
            'SHIB', 'WBTC', 'DAI', 'BUSD', 'USDC', 'APE', 'SAND', 'MANA', 'AXS', 'CHZ'
        ];
        
        return validSymbols.includes(symbol) && symbol.length >= 2 && symbol.length <= 10;
    }

    extractSignalInfo(text) {
        try {
            const info = {
                direction: null,
                entryPrices: [],
                takeProfits: [],
                stopLoss: null,
                leverage: null
            };

            // Detectar direcci√≥n LONG/SHORT
            if (/LONG/i.test(text)) info.direction = 'LONG';
            if (/SHORT/i.test(text)) info.direction = 'SHORT';

            // Extraer precios de entrada (mejorado)
            const entrySection = text.match(/ENTRADA[\s\S]*?(?=üöÄ|TP|Apalancamiento|STOP)/i);
            if (entrySection) {
                const priceMatches = entrySection[0].match(/\$\s*([\d.]+)/g);
                if (priceMatches) {
                    priceMatches.forEach(match => {
                        const price = match.match(/\$\s*([\d.]+)/);
                        if (price) info.entryPrices.push(parseFloat(price[1]));
                    });
                }
            }

            // Extraer Take Profits
            const tpMatches = text.match(/(\d+)\s*%\s*\(\$\s*([\d.]+)\)/gi);
            if (tpMatches) {
                tpMatches.forEach(match => {
                    const parts = match.match(/(\d+)\s*%\s*\(\$\s*([\d.]+)\)/i);
                    if (parts) {
                        info.takeProfits.push({
                            percentage: parseInt(parts[1]),
                            price: parseFloat(parts[2])
                        });
                    }
                });
            }

            // Extraer Stop Loss
            const slMatch = text.match(/STOP\s*LOSS[:\s]*[\d.]+\s*%\s*\(\$\s*([\d.]+)\)/i);
            if (slMatch) {
                info.stopLoss = parseFloat(slMatch[1]);
            }

            // Extraer Apalancamiento
            const leverageMatch = text.match(/Apalancamiento.*?(\d+)\s*X/i);
            if (leverageMatch) {
                info.leverage = parseInt(leverageMatch[1]);
            }

            return info;
        } catch (error) {
            this.logger.error('Error extrayendo informaci√≥n de se√±al:', error);
            return {};
        }
    }

    async performUltraFastAnalysis(symbol, signalInfo, messageId) {
        try {
            this.logger.info(`‚ö° AN√ÅLISIS ULTRA R√ÅPIDO: ${symbol} ${signalInfo.direction || 'DETECTANDO'}`);
            
            const startTime = Date.now();
            
            // 1. Obtener datos de mercado R√ÅPIDO
            const marketData = await this.binanceAPI.getMarketData(symbol);
            if (!marketData) {
                this.logger.error(`‚ùå No se pudieron obtener datos de ${symbol}`);
                return;
            }

            // 2. An√°lisis t√©cnico ULTRA R√ÅPIDO (Smart Money, Soportes, Resistencias)
            const ultraAnalysis = await this.performSmartMoneyAnalysis(symbol, marketData, signalInfo);
            
            // 3. DECISI√ìN INMEDIATA: ENTRAR, ESPERAR
            const decision = this.makeInstantDecision(ultraAnalysis, signalInfo);
            
            // 4. Enviar respuesta INMEDIATA
            await this.sendUltraFastResponse(decision, symbol, signalInfo);
            
            const analysisTime = Date.now() - startTime;
            this.logger.info(`‚ö° An√°lisis completado en ${analysisTime}ms`);

        } catch (error) {
            this.logger.error(`Error en an√°lisis ultra r√°pido de ${symbol}:`, error);
        }
    }

    async performSmartMoneyAnalysis(symbol, marketData, signalInfo) {
        return await this.smartMoneyAnalyzer.performSmartMoneyAnalysis(symbol, marketData, signalInfo);
    }

    makeInstantDecision(ultraAnalysis, signalInfo) {
        return this.smartMoneyAnalyzer.makeInstantDecision(ultraAnalysis, signalInfo);
    }

    async sendUltraFastResponse(decision, symbol, signalInfo) {
        try {
            // Enviar al chat F77 configurado
            const chatId = process.env.TELEGRAM_CHAT_ID_F77;
            
            const directionEmoji = decision.action.includes('LONG') ? 'üü¢' : 
                                 decision.action.includes('SHORT') ? 'üî¥' : '‚ö™';
            
            const confidenceEmoji = decision.confidence >= 80 ? 'üî•üî•üî•' :
                                  decision.confidence >= 70 ? 'üî•üî•' :
                                  decision.confidence >= 60 ? 'üî•' : '‚ö°';

            // Determinar la recomendaci√≥n clara
            let recommendation = '';
            if (decision.action.includes('ENTRAR LONG')) {
                recommendation = 'üü¢ ENTRAR LONG';
            } else if (decision.action.includes('ENTRAR SHORT')) {
                recommendation = 'üî¥ ENTRAR SHORT';
            } else if (decision.action.includes('LONG')) {
                recommendation = 'üü¢ ENTRAR LONG';
            } else if (decision.action.includes('SHORT')) {
                recommendation = 'üî¥ ENTRAR SHORT';
            } else {
                recommendation = '‚ö™ ESPERAR';
            }

            // Agregar recomendaci√≥n espec√≠fica solo si es ESPERAR
            const waitRecommendationText = (recommendation === '‚ö™ ESPERAR' && decision.waitRecommendation) ? 
                `\n‚è≥ <b>QU√â ESPERAR:</b> ${decision.waitRecommendation}` : '';

            const message = `
ü§ñ <b>BOT F77 - AN√ÅLISIS PROFESIONAL</b>
${directionEmoji} <b>${symbol}</b>

üéØ <b>RECOMENDACI√ìN: ${recommendation}</b>
üìä Confianza: ${decision.confidence}% ${confidenceEmoji}${waitRecommendationText}

üìã <b>SE√ëAL ORIGINAL:</b> ${signalInfo.direction || 'N/A'}
üí∞ <b>Precio Actual:</b> $${decision.analysis?.currentPrice || 'N/A'}
${signalInfo.entryPrices?.length ? `üéØ <b>Entry Sugerido:</b> $${signalInfo.entryPrices[0]}` : ''}
${signalInfo.stopLoss ? `üõë <b>Stop Loss:</b> $${signalInfo.stopLoss}` : ''}

üìä <b>AN√ÅLISIS T√âCNICO:</b>
‚Ä¢ Smart Money: ${decision.analysis?.smartMoneyScore || 0}/5 ‚≠ê
‚Ä¢ Momentum: ${decision.analysis?.momentum?.direction || 'NEUTRAL'}
‚Ä¢ Volumen: ${decision.analysis?.volumeAnalysis?.level || 'NORMAL'}

üí° <b>RAZONES:</b>
${decision.reasons.map(r => `‚Ä¢ ${r}`).join('\n')}

‚è∞ <i>An√°lisis autom√°tico en tiempo real</i>
            `.trim();

            // Usar bot API para enviar (m√°s confiable)
            await this.bot.sendMessage(chatId, message, {
                parse_mode: 'HTML',
                disable_web_page_preview: true
            });

            this.logger.info(`‚úÖ Respuesta ultra r√°pida enviada: ${decision.action} - ${decision.confidence}%`);

            // üöÄ TRADING AUTOM√ÅTICO - Procesar se√±al si cumple criterios
            try {
                await this.autoTrader.processSignal(symbol, decision.action, decision.confidence, decision);
            } catch (error) {
                this.logger.error('‚ùå Error en AutoTrader:', error.message);
            }

        } catch (error) {
            this.logger.error('Error enviando respuesta ultra r√°pida:', error);
        }
    }

    async performProfessionalAnalysis(symbol, messageId) {
        try {
            this.logger.info(`üîç Iniciando an√°lisis profesional de ${symbol}`);
            
            // Evitar an√°lisis duplicados
            const signalKey = `${symbol}_${Date.now()}`;
            if (this.processedSignals.has(signalKey)) {
                return;
            }
            this.processedSignals.add(signalKey);

            // 1. Obtener datos de mercado
            const marketData = await this.binanceAPI.getMarketData(symbol);
            if (!marketData) {
                this.logger.error(`‚ùå No se pudieron obtener datos de ${symbol}`);
                return;
            }

            // 2. Realizar an√°lisis t√©cnico profesional
            const analysis = await this.technicalAnalyzer.performCompleteAnalysis(symbol, marketData);
            
            // 3. Generar se√±al profesional
            const signal = await this.signalGenerator.generateProfessionalSignal(analysis);
            
            // 4. Validar confianza m√≠nima
            if (signal.confidence < process.env.MIN_CONFIDENCE_LEVEL) {
                this.logger.warn(`‚ö†Ô∏è Confianza insuficiente para ${symbol}: ${signal.confidence}%`);
                return;
            }

            // 5. Enviar se√±al a f77
            await this.sendProfessionalSignal(signal);
            
            // 6. Guardar an√°lisis
            await this.saveAnalysis(signal, messageId);
            
            this.signalCount.hourly++;
            this.logger.info(`‚úÖ Se√±al enviada para ${symbol} - Confianza: ${signal.confidence}%`);

        } catch (error) {
            this.logger.error(`Error en an√°lisis profesional de ${symbol}:`, error);
        }
    }

    async sendProfessionalSignal(signal) {
        try {
            const chatId = process.env.TELEGRAM_CHAT_ID_F77;
            
            const message = this.formatProfessionalSignal(signal);
            
            await this.bot.sendMessage(chatId, message, {
                parse_mode: 'HTML',
                disable_web_page_preview: true
            });

            // Enviar imagen de an√°lisis si est√° disponible
            if (signal.analysisImagePath) {
                await this.bot.sendPhoto(chatId, signal.analysisImagePath, {
                    caption: `üìä An√°lisis t√©cnico detallado de ${signal.symbol}`
                });
            }

        } catch (error) {
            this.logger.error('Error enviando se√±al profesional:', error);
        }
    }

    formatProfessionalSignal(signal) {
        const directionEmoji = signal.direction === 'LONG' ? 'üü¢' : 'üî¥';
        const strengthEmoji = this.getStrengthEmoji(signal.confidence);
        
        return `
ü§ñ <b>DEF BINANCE PROFESSIONAL</b>
${directionEmoji} <b>${signal.direction} ${signal.symbol}</b>

üìä <b>AN√ÅLISIS T√âCNICO:</b>
‚Ä¢ Confianza: ${signal.confidence}% ${strengthEmoji}
‚Ä¢ Precio Actual: $${signal.currentPrice}
‚Ä¢ Timeframe: ${signal.timeframe}

üéØ <b>SOPORTES Y RESISTENCIAS:</b>
‚Ä¢ Soporte: $${signal.support}
‚Ä¢ Resistencia: $${signal.resistance}
‚Ä¢ Zona Cr√≠tica: $${signal.criticalZone}

üìà <b>INDICADORES:</b>
‚Ä¢ RSI: ${signal.rsi} ${this.getRSIStatus(signal.rsi)}
‚Ä¢ MACD: ${signal.macd} ${signal.macdSignal}
‚Ä¢ Bollinger: ${signal.bollingerPosition}
‚Ä¢ Volume: ${signal.volumeAnalysis}

‚ö° <b>ACCI√ìN DEL PRECIO:</b>
${signal.priceAction}

üé≤ <b>ESTRATEGIA:</b>
‚Ä¢ Entry: $${signal.entryPrice}
‚Ä¢ Stop Loss: $${signal.stopLoss}
‚Ä¢ Take Profit: $${signal.takeProfit}
‚Ä¢ Risk/Reward: 1:${signal.riskReward}

‚è∞ <i>An√°lisis: ${new Date().toLocaleString()}</i>
üî• <i>Se√±al autom√°tica - Verificar antes de operar</i>
        `.trim();
    }

    getStrengthEmoji(confidence) {
        if (confidence >= 90) return 'üî•üî•üî•';
        if (confidence >= 80) return 'üî•üî•';
        if (confidence >= 70) return 'üî•';
        return '‚ö°';
    }

    getRSIStatus(rsi) {
        if (rsi < 30) return '(Oversold üìâ)';
        if (rsi > 70) return '(Overbought üìà)';
        return '(Neutral ‚öñÔ∏è)';
    }

    checkHourlyLimit() {
        const currentHour = new Date().getHours();
        if (currentHour !== this.signalCount.lastHour) {
            this.signalCount.hourly = 0;
            this.signalCount.lastHour = currentHour;
        }
        
        return this.signalCount.hourly < process.env.MAX_SIGNALS_PER_HOUR;
    }

    async saveAnalysis(signal, messageId) {
        try {
            const analysisData = {
                timestamp: new Date().toISOString(),
                messageId: messageId,
                signal: signal,
                processed: true
            };
            
            const filename = `./data/analysis/${signal.symbol}_${Date.now()}.json`;
            await fs.writeJSON(filename, analysisData, { spaces: 2 });
            
        } catch (error) {
            this.logger.error('Error guardando an√°lisis:', error);
        }
    }

    async manualAnalysis(chatId, symbol) {
        try {
            await this.bot.sendMessage(chatId, `üîç Analizando ${symbol}...`);
            await this.performProfessionalAnalysis(symbol, 'manual');
            
        } catch (error) {
            await this.bot.sendMessage(chatId, `‚ùå Error analizando ${symbol}: ${error.message}`);
        }
    }

    async testSignal(chatId) {
        try {
            await this.bot.sendMessage(chatId, `üß™ Generando se√±al de prueba...`);
            
            // Simular an√°lisis de BTCUSDT
            const mockAnalysis = {
                symbol: 'BTCUSDT',
                currentPrice: '67250.50',
                timeframe: '15m',
                rsi: 45,
                macd: 'BULLISH',
                bollingerPosition: 'Mitad superior',
                volumeAnalysis: 'Alto',
                priceChange: 1.2,
                volumeIncrease: true,
                volatility: 0.025
            };

            // Generar se√±al
            const signal = await this.signalGenerator.generateProfessionalSignal(mockAnalysis);
            
            if (signal) {
                // Enviar al grupo f77
                const f77ChatId = process.env.TELEGRAM_CHAT_ID_F77;
                await this.sendProfessionalSignal(signal);
                await this.bot.sendMessage(chatId, `‚úÖ Se√±al de prueba enviada al grupo f77`);
            }
            
        } catch (error) {
            await this.bot.sendMessage(chatId, `‚ùå Error en prueba: ${error.message}`);
        }
    }

    async createTestSignal(chatId) {
        try {
            await this.bot.sendMessage(chatId, `üß™ Creando se√±al de prueba completa...`);
            
            // Crear una se√±al realista de BTCUSDT
            const testSignalText = `üì• #BTCUSDT üü¢ LONG

üéØ ENTRADA
  1‚É£  $ 67250.00
  2‚É£  $ 66800.00

üöÄ TP'S
  1‚É£  5 % ($ 70612.50)
  2‚É£  10 % ($ 73975.00)

Apalancamiento m√°ximo 10 X

üõë STOP LOSS: 2.5 % ($ 65568.75)`;

            await this.bot.sendMessage(chatId, `üìù Se√±al de prueba creada:\n\n${testSignalText}`);
            
            // Simular el procesamiento como si viniera del grupo
            console.log(chalk.blue('üß™ Procesando se√±al de prueba...'));
            
            // Extraer informaci√≥n de la se√±al
            const symbol = this.extractSymbolFromText(testSignalText);
            const signalInfo = this.extractSignalInfo(testSignalText);
            
            if (symbol) {
                console.log(chalk.green(`üéØ Token detectado en prueba: ${symbol}`));
                await this.performUltraFastAnalysis(symbol, signalInfo, 'test_signal');
                await this.bot.sendMessage(chatId, `‚úÖ Se√±al procesada y enviada al bot F77`);
            } else {
                await this.bot.sendMessage(chatId, `‚ùå No se pudo extraer el s√≠mbolo de la se√±al`);
            }
            
        } catch (error) {
            console.error('Error creando se√±al de prueba:', error);
            await this.bot.sendMessage(chatId, `‚ùå Error creando se√±al: ${error.message}`);
        }
    }

    async sendAutomaticTestSignal() {
        try {
            console.log(chalk.blue('üöÄ Enviando se√±al de prueba autom√°tica...'));
            
            // Crear una se√±al realista de BTCUSDT
            const testSignalText = `üì• #BTCUSDT üü¢ LONG

üéØ ENTRADA
  1‚É£  $ 67250.00
  2‚É£  $ 66800.00

üöÄ TP'S
  1‚É£  5 % ($ 70612.50)
  2‚É£  10 % ($ 73975.00)

Apalancamiento m√°ximo 10 X

üõë STOP LOSS: 2.5 % ($ 65568.75)`;

            console.log(chalk.yellow('üìù Se√±al de prueba creada autom√°ticamente'));
            
            // Extraer informaci√≥n de la se√±al
            const symbol = this.extractSymbolFromText(testSignalText);
            const signalInfo = this.extractSignalInfo(testSignalText);
            
            if (symbol) {
                console.log(chalk.green(`üéØ Token detectado autom√°ticamente: ${symbol}`));
                await this.performUltraFastAnalysis(symbol, signalInfo, 'auto_test');
                console.log(chalk.green('‚úÖ Se√±al de prueba procesada y enviada autom√°ticamente'));
            } else {
                console.log(chalk.red('‚ùå No se pudo extraer el s√≠mbolo de la se√±al autom√°tica'));
            }
            
        } catch (error) {
            console.error(chalk.red('Error enviando se√±al autom√°tica:'), error);
        }
    }

    async testDirectMessage() {
        try {
            const chatId = process.env.TELEGRAM_CHAT_ID_F77;
            console.log(chalk.blue(`üß™ Probando env√≠o directo a chat ${chatId}...`));
            
            await this.bot.sendMessage(chatId, `üß™ Mensaje de prueba - ${new Date().toLocaleTimeString()}`);
            console.log(chalk.green('‚úÖ Mensaje de prueba enviado correctamente'));
            
        } catch (error) {
            console.error(chalk.red('‚ùå Error enviando mensaje de prueba:'), error);
            console.log(chalk.yellow('üí° Verifica que el token del bot sea correcto'));
        }
    }

    async checkGroupAccess(chatId) {
        try {
            const sourceChannelId = process.env.SOURCE_CHANNEL_ID;
            const f77ChatId = process.env.TELEGRAM_CHAT_ID_F77;
            
            await this.bot.sendMessage(chatId, `üîç Verificando acceso a grupos...`);
            
            let message = `üìä <b>DIAGN√ìSTICO DEL BOT</b>\n\n`;
            
            // Verificar grupo fuente
            try {
                const sourceChat = await this.bot.getChat(sourceChannelId);
                message += `‚úÖ <b>Grupo Fuente:</b> ${sourceChat.title || 'Sin t√≠tulo'}\n`;
                message += `üìã ID: ${sourceChannelId}\n`;
                message += `üë• Tipo: ${sourceChat.type}\n\n`;
            } catch (error) {
                message += `‚ùå <b>Grupo Fuente:</b> No accesible\n`;
                message += `üìã ID: ${sourceChannelId}\n`;
                message += `üö´ Error: ${error.message}\n\n`;
            }
            
            // Verificar grupo f77
            try {
                const f77Chat = await this.bot.getChat(f77ChatId);
                message += `‚úÖ <b>Grupo F77:</b> ${f77Chat.title || 'Sin t√≠tulo'}\n`;
                message += `üìã ID: ${f77ChatId}\n`;
                message += `üë• Tipo: ${f77Chat.type}\n\n`;
            } catch (error) {
                message += `‚ùå <b>Grupo F77:</b> No accesible\n`;
                message += `üìã ID: ${f77ChatId}\n`;
                message += `üö´ Error: ${error.message}\n\n`;
            }
            
            // Informaci√≥n del chat actual
            message += `üí¨ <b>Chat Actual:</b>\n`;
            message += `üìã ID: ${chatId}\n`;
            message += `ü§ñ Bot funcionando: ‚úÖ\n`;
            
            await this.bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
            
        } catch (error) {
            await this.bot.sendMessage(chatId, `‚ùå Error en verificaci√≥n: ${error.message}`);
        }
    }

    sendWelcomeMessage(chatId) {
        const message = `
ü§ñ <b>DEF BINANCE PROFESSIONAL BOT</b>

üéØ <b>Funciones:</b>
‚Ä¢ An√°lisis t√©cnico profesional
‚Ä¢ Detecci√≥n autom√°tica de se√±ales
‚Ä¢ Soportes y resistencias
‚Ä¢ Predicci√≥n SHORT/LONG

üìä <b>Comandos:</b>
/status - Estado del bot
/analyze SYMBOL - An√°lisis manual
/test - Enviar se√±al de prueba
/check - Verificar acceso a grupos

üöÄ <b>Trading Autom√°tico:</b>
/trading_enable - Habilitar trading autom√°tico
/trading_disable - Deshabilitar trading autom√°tico
/trading_stats - Estad√≠sticas de trading

üî• <b>Bot activo y monitoreando...</b>
        `;
        
        this.bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
    }

    sendStatusMessage(chatId) {
        const message = `
üìä <b>ESTADO DEL BOT</b>

üü¢ Estado: Activo
üìà Se√±ales enviadas (hora): ${this.signalCount.hourly}/${process.env.MAX_SIGNALS_PER_HOUR}
üéØ Confianza m√≠nima: ${process.env.MIN_CONFIDENCE_LEVEL}%
‚è∞ √öltimo reinicio: ${new Date().toLocaleString()}

üî• <b>Monitoreando Grupo de Se√±ales</b>
        `;
        
        this.bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
    }

    start() {
        this.isRunning = true;
        this.logger.info('üöÄ Bot DefBinance Professional iniciado correctamente');
        
        // Limpiar se√±ales procesadas cada hora
        setInterval(() => {
            this.processedSignals.clear();
            this.logger.info('üßπ Cache de se√±ales limpiado');
        }, 3600000); // 1 hora
    }

    async findVolumenGroup(chatId) {
        try {
            await this.bot.sendMessage(chatId, `üîç Buscando subgrupo "VOLUMEN"...`);
            
            if (!this.telegramClient) {
                await this.bot.sendMessage(chatId, `‚ùå Telegram API no disponible`);
                return;
            }

            const dialogs = await this.telegramClient.getDialogs({ limit: 200 });
            
            let message = `üìã <b>BUSCANDO SUBGRUPO "VOLUMEN"</b>\n\n`;
            let found = false;
            
            for (const dialog of dialogs) {
                const entity = dialog.entity;
                const title = entity.title || '';
                
                if (title.toLowerCase().includes('volumen') || 
                    title.toLowerCase().includes('volume') ||
                    title.toUpperCase().includes('VOLUMEN')) {
                    
                    found = true;
                    const id = entity.id ? `-100${entity.id}` : 'Sin ID';
                    const type = entity.className;
                    
                    message += `‚úÖ <b>ENCONTRADO: ${title}</b>\n`;
                    message += `   üìã ID: <code>${id}</code>\n`;
                    message += `   üë• Tipo: ${type}\n`;
                    message += `   üîó Enlace: https://t.me/c/${id.replace('-100', '')}/1\n\n`;
                    
                    if (title.toLowerCase() === 'volumen') {
                        message += `üéØ <b>RECOMENDADO:</b> Este es el subgrupo correcto\n\n`;
                    }
                }
            }
            
            if (!found) {
                message += `‚ùå No se encontr√≥ subgrupo "VOLUMEN"\n`;
                message += `üí° Usa /listgroups para ver todos los grupos\n`;
            }
            
            await this.bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
            
        } catch (error) {
            await this.bot.sendMessage(chatId, `‚ùå Error: ${error.message}`);
        }
    }

    // üöÄ M√âTODOS DE TRADING AUTOM√ÅTICO
    async handleTradingEnable(chatId) {
        try {
            this.autoTrader.enableTrading(true);
            
            const stats = this.autoTrader.getStats();
            const message = `
üöÄ <b>TRADING AUTOM√ÅTICO HABILITADO</b>

‚ö†Ô∏è <b>CONFIGURACI√ìN DE SEGURIDAD:</b>
üí∞ Monto por operaci√≥n: $1.00 USD
üõë Stop Loss: -$0.50 USD
üéØ Take Profit: +$1.00 USD
üìä Confianza m√≠nima: ${stats.minConfidence}%
üìà M√°x. operaciones/d√≠a: ${stats.maxDailyTrades}
üîí M√°x. posiciones abiertas: ${stats.maxOpenPositions}

‚úÖ <b>El bot ejecutar√° operaciones autom√°ticamente cuando detecte se√±ales de alta confianza (${stats.minConfidence}%+)</b>

‚ö†Ô∏è <i>Usa esta funci√≥n bajo tu propia responsabilidad</i>
            `.trim();
            
            await this.bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
            this.logger.info('üöÄ Trading autom√°tico HABILITADO por usuario');
            
        } catch (error) {
            await this.bot.sendMessage(chatId, `‚ùå Error habilitando trading: ${error.message}`);
        }
    }

    async handleTradingDisable(chatId) {
        try {
            this.autoTrader.enableTrading(false);
            
            const message = `
üõë <b>TRADING AUTOM√ÅTICO DESHABILITADO</b>

‚úÖ El bot ya NO ejecutar√° operaciones autom√°ticamente
üìä Solo enviar√° an√°lisis y recomendaciones
üîí Todas las funciones de seguridad mantienen activas

üí° Para reactivar usa: /trading_enable
            `.trim();
            
            await this.bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
            this.logger.info('üõë Trading autom√°tico DESHABILITADO por usuario');
            
        } catch (error) {
            await this.bot.sendMessage(chatId, `‚ùå Error deshabilitando trading: ${error.message}`);
        }
    }

    async handleTradingStats(chatId) {
        try {
            const stats = this.autoTrader.getStats();
            
            const message = `
üìä <b>ESTAD√çSTICAS DE TRADING AUTOM√ÅTICO</b>

üîÑ <b>Estado:</b> ${stats.tradingEnabled ? '‚úÖ HABILITADO' : 'üõë DESHABILITADO'}

üìà <b>Operaciones Hoy:</b> ${stats.dailyTrades}/${stats.maxDailyTrades}
üîí <b>Posiciones Abiertas:</b> ${stats.openPositions}/${stats.maxOpenPositions}
üìä <b>Confianza M√≠nima:</b> ${stats.minConfidence}%

üí∞ <b>Configuraci√≥n:</b>
‚Ä¢ Monto: $1.00 USD por operaci√≥n
‚Ä¢ Stop Loss: -$0.50 USD
‚Ä¢ Take Profit: +$1.00 USD

‚ö†Ô∏è <b>L√≠mites de Seguridad:</b>
‚Ä¢ M√°x. ${stats.maxDailyTrades} operaciones/d√≠a
‚Ä¢ M√°x. ${stats.maxOpenPositions} posiciones simult√°neas
‚Ä¢ Solo se√±ales ${stats.minConfidence}%+ confianza
            `.trim();
            
            await this.bot.sendMessage(chatId, message, { parse_mode: 'HTML' });
            
        } catch (error) {
            await this.bot.sendMessage(chatId, `‚ùå Error obteniendo estad√≠sticas: ${error.message}`);
        }
    }

    stop() {
        this.isRunning = false;
        this.bot.stopPolling();
        this.logger.info('üõë Bot DefBinance Professional detenido');
    }
}

// Servidor web simple para Render
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => {
    res.json({
        status: 'Bot DefBinance funcionando correctamente',
        uptime: process.uptime(),
        timestamp: new Date().toISOString()
    });
});

app.get('/health', (req, res) => {
    res.json({ status: 'healthy', bot: 'running' });
});

app.get('/ip', async (req, res) => {
    try {
        const axios = require('axios');
        const ipResponse = await axios.get('https://api.ipify.org?format=json');
        res.json({ 
            server_ip: ipResponse.data.ip,
            timestamp: new Date().toISOString(),
            region: 'Frankfurt EU Central'
        });
    } catch (error) {
        res.json({ error: error.message });
    }
});

app.listen(PORT, () => {
    console.log(`üåê Servidor web iniciado en puerto ${PORT}`);
});

// Keep-alive ping cada 3 minutos para evitar spin down
setInterval(() => {
    const axios = require('axios');
    const url = process.env.RENDER_EXTERNAL_URL || `http://localhost:${PORT}`;
    
    axios.get(`${url}/health`)
        .then(() => console.log('üèì Keep-alive ping exitoso'))
        .catch(() => console.log('üèì Keep-alive ping (manteniendo despierto)'));
}, 3 * 60 * 1000); // 3 minutos

const bot = new DefBinanceProfessionalBot();
bot.start();

// Manejo de se√±ales del sistema
process.on('SIGINT', () => {
    console.log(chalk.yellow('\nüëã Cerrando DefBinance Professional Bot...'));
    bot.stop();
    process.exit(0);
});

process.on('SIGTERM', () => {
    console.log(chalk.yellow('\n‚ö†Ô∏è SIGTERM recibido - Cerrando gracefully...'));
    bot.stop();
    process.exit(0);
});

// Monitoreo de memoria cada 30 segundos
setInterval(() => {
    const memUsage = process.memoryUsage();
    const memMB = Math.round(memUsage.heapUsed / 1024 / 1024);
    console.log(`üìä Memoria: ${memMB}MB`);
    
    // Si usa m√°s de 400MB, forzar garbage collection
    if (memMB > 400 && global.gc) {
        global.gc();
        console.log('üßπ Garbage collection ejecutado');
    }
}, 30000);

process.on('uncaughtException', (error) => {
    console.error(chalk.red('Error no capturado:'), error);
});

module.exports = DefBinanceProfessionalBot;
